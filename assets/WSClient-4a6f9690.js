var u=Object.defineProperty;var w=(r,t,s)=>t in r?u(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s;var e=(r,t,s)=>(w(r,typeof t!="symbol"?t+"":t,s),s);class b{constructor(t){e(this,"url");e(this,"ws",null);e(this,"status","idle");e(this,"heartbeatTimer",null);e(this,"lastAliveAt",0);e(this,"reconnectDelay");e(this,"hbInterval");e(this,"hbTimeout");e(this,"maxDelay");e(this,"manualClose",!1);e(this,"onStatus");e(this,"onOpen");e(this,"onClose");e(this,"onError");e(this,"onMessage");this.url=t.url,this.hbInterval=t.heartbeatIntervalMs??1e4,this.hbTimeout=t.heartbeatTimeoutMs??15e3,this.reconnectDelay=t.reconnectInitialDelayMs??2e3,this.maxDelay=t.reconnectMaxDelayMs??3e4}setStatus(t){var s;this.status=t,(s=this.onStatus)==null||s.call(this,t)}startHeartbeat(){this.stopHeartbeat(),this.lastAliveAt=Date.now();const t=()=>{var n,i;try{(n=this.ws)==null||n.send(JSON.stringify({type:"ping"}))}catch{}if(Date.now()-this.lastAliveAt>this.hbTimeout){(i=this.ws)==null||i.close(4001,"heartbeat timeout");return}this.heartbeatTimer=window.setTimeout(t,this.hbInterval)};this.heartbeatTimer=window.setTimeout(t,this.hbInterval)}stopHeartbeat(){this.heartbeatTimer!=null&&(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null)}connect(t){return t&&(this.url=t),this.setStatus("connecting"),new Promise((s,l)=>{const n=new WebSocket(this.url);this.ws=n,n.onopen=()=>{var i;this.setStatus("open"),this.reconnectDelay=Math.min(this.reconnectDelay,2e3),this.lastAliveAt=Date.now(),this.startHeartbeat(),(i=this.onOpen)==null||i.call(this),s()},n.onmessage=i=>{var a,o,c;this.lastAliveAt=Date.now();try{const h=JSON.parse(i.data);if(h&&h.type==="pong"){(a=this.onMessage)==null||a.call(this,h);return}(o=this.onMessage)==null||o.call(this,h)}catch{(c=this.onMessage)==null||c.call(this,String(i.data))}},n.onerror=i=>{var a;this.setStatus("error"),(a=this.onError)==null||a.call(this,i),l(new Error("ws error"))},n.onclose=i=>{var a;if(this.setStatus("closed"),this.stopHeartbeat(),(a=this.onClose)==null||a.call(this,i),this.manualClose)this.manualClose=!1;else{const o=this.reconnectDelay;this.reconnectDelay=Math.min(this.reconnectDelay*2,this.maxDelay),window.setTimeout(()=>{this.status==="closed"&&this.connect().catch(c=>{})},o)}}})}disconnect(t,s){this.setStatus("closing"),this.stopHeartbeat(),this.manualClose=!0;try{this.ws&&(this.ws.close(t??1e3,s??"client close"),this.ws.onopen=null,this.ws.onmessage=null,this.ws.onerror=null,this.ws.onclose=null)}catch{}this.ws=null,this.setStatus("closed")}send(t){if(!this.ws||this.ws.readyState!==WebSocket.OPEN)throw new Error("ws not open");typeof t=="string"?this.ws.send(t):this.ws.send(JSON.stringify(t))}getStatus(){return this.status}}export{b as W};
