var u=Object.defineProperty;var w=(r,t,s)=>t in r?u(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s;var e=(r,t,s)=>(w(r,typeof t!="symbol"?t+"":t,s),s);class m{constructor(t){e(this,"url");e(this,"ws",null);e(this,"status","idle");e(this,"heartbeatTimer",null);e(this,"lastAliveAt",0);e(this,"reconnectDelay");e(this,"hbInterval");e(this,"hbTimeout");e(this,"maxDelay");e(this,"onStatus");e(this,"onOpen");e(this,"onClose");e(this,"onError");e(this,"onMessage");this.url=t.url,this.hbInterval=t.heartbeatIntervalMs??1e4,this.hbTimeout=t.heartbeatTimeoutMs??15e3,this.reconnectDelay=t.reconnectInitialDelayMs??2e3,this.maxDelay=t.reconnectMaxDelayMs??3e4}setStatus(t){var s;this.status=t,(s=this.onStatus)==null||s.call(this,t)}startHeartbeat(){this.stopHeartbeat(),this.lastAliveAt=Date.now();const t=()=>{var a,i;try{(a=this.ws)==null||a.send(JSON.stringify({type:"ping"}))}catch{}if(Date.now()-this.lastAliveAt>this.hbTimeout){(i=this.ws)==null||i.close(4001,"heartbeat timeout");return}this.heartbeatTimer=window.setTimeout(t,this.hbInterval)};this.heartbeatTimer=window.setTimeout(t,this.hbInterval)}stopHeartbeat(){this.heartbeatTimer!=null&&(clearTimeout(this.heartbeatTimer),this.heartbeatTimer=null)}connect(t){return t&&(this.url=t),this.setStatus("connecting"),new Promise((s,o)=>{const a=new WebSocket(this.url);this.ws=a,a.onopen=()=>{var i;this.setStatus("open"),this.reconnectDelay=Math.min(this.reconnectDelay,2e3),this.lastAliveAt=Date.now(),this.startHeartbeat(),(i=this.onOpen)==null||i.call(this),s()},a.onmessage=i=>{var n,h,c;this.lastAliveAt=Date.now();try{const l=JSON.parse(i.data);if(l&&l.type==="pong"){(n=this.onMessage)==null||n.call(this,l);return}(h=this.onMessage)==null||h.call(this,l)}catch{(c=this.onMessage)==null||c.call(this,String(i.data))}},a.onerror=i=>{var n;this.setStatus("error"),(n=this.onError)==null||n.call(this,i),o(new Error("ws error"))},a.onclose=i=>{var h;this.setStatus("closed"),this.stopHeartbeat(),(h=this.onClose)==null||h.call(this,i);const n=this.reconnectDelay;this.reconnectDelay=Math.min(this.reconnectDelay*2,this.maxDelay),window.setTimeout(()=>{this.status==="closed"&&this.connect().catch(c=>{})},n)}})}disconnect(t,s){var o;this.setStatus("closing"),this.stopHeartbeat();try{(o=this.ws)==null||o.close(t??1e3,s??"client close")}catch{}this.ws=null,this.setStatus("closed")}send(t){if(!this.ws||this.ws.readyState!==WebSocket.OPEN)throw new Error("ws not open");typeof t=="string"?this.ws.send(t):this.ws.send(JSON.stringify(t))}getStatus(){return this.status}}export{m as W};
